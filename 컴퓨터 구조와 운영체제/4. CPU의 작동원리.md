# 4. CPU의 작동원리

### ALU와 제어장치
> ALU가 구성하는 회로, 제어장치를 구성하는 회로는 해당 챕터에서 다루지 않는다. ALU가 내보내고 받아들이는 정보, 제어장치가 내보내고 받아들이는 정보에 대한 챕터이다.

#### ALU
* 레지스터로 부터 피연산자를 받아들이고 제어장치로부터 제어 신호를 받아들여서 계산을 하게 된다. 계산 값을 레지스터에 다시 담아준다.
* 계산 값을 메모리가 아닌 레지스터에 저장하는 이유는 CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 더 빠르기 때문에 사용한다.

#### 플래그
* 연산 결과에 대한 부가 정보로 양수인지, 음수인지 내보내지고 플래그 레지스터에 저장이 되어진다. 
* 예를 들어 계산 값이 -10일 경우 -10이 레지스터에 저장되면서 플래그 레지스터에는 해당 값이 음수라고 아래처럼 저장이 된다. 즉, 음수일 때는 부호 플래그만 1로 들어가면 음수라고 인식한다고 보면 된다.
* `부호 플래그: 1` `제로 플래그: 0` `캐리 플래그: 0` `오버플로우 플래그: 0` `인터럽트 플래그: 0` `슈퍼바이저 플래그: 0`

</br>

#### 💡 플래그 종류
|플래그 종류| 의미           | 사용 예시  | 
|-------------------|--------------------|:--------------------:|
|부호 플래그|연산한 결과의 부호를 나타낸다.|1일 경우 음수, 0일 경우 양수|
|제로 플래그|연산 결과가 0인지 여부를 나타낸다.|1일 경우 0, 0일 경우 0이 아닌 수|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.|1일 경우 발생했고, 0일 경우 발생하지 않음|
|오버플로우 플래그|오버플로우가 발생했는지를 나타낸다.|1일 경우 발생했고, 0일 경우 발생하지 않음|
|인터럽트 플래그|인터럽트가 가능한지를 나타낸다.|1일 경우 인터럽트 가능, 0일 경우 불가능함|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.|1일 경우 커널 모드 실행중, 0일 경우 사용자 모드 실행중|

</br>

#### 제어장치(받아들이는 정보 3가지)
**(1) 클럭(= 시계)**
* 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위로 일정한 박자에 맞춰서 발생하는 신호로 이해하면 된다.
* 메모리에서 명령어 가져오는 주기는 클럭주기x5 단위로 수행된다고 보면 된다.

**(2) 명령어 레지스터(= 해석할 명령어)**
* 명령어 레지스터로부터 해석할 명령어를 받아들이고 제어장치에서 해석한다.
* 다음 강의에 자세히..😅

**(3) 플래그**
* 플래그 레지스터(= CPU가 연산 결과로서 받아들이는 부가 정보)의 플래그를 받아야 해석할 명령어가 음수인지, 양수인지 부가 정보에 대해 해석할 수 있다.

</br>

### 레지스터
* 레지스터는 CPU 내부의 작은 임시저장장치로 프로그램의 명령어, 데이터는 실행 전후로 레지스터에 저장된다.

#### (1) 프로그램 카운터
* 메모리에서 가져올 명령어의 주소를 저장한다.(= 메모리에서 읽어 들일 명령어의 주소)

#### (2) 명령어 레지스터
* 방금 메모리에서 읽어 들인 명령어로 제어장치가 해석할 명령어이다.

#### (3) 메모리 주소 레지스터
* CPU가 읽어 들이고자 하는 주소를 주소 버스를 보낼 때 거치는 레지스터이다.

#### (4) 메모리 버퍼 레지스터
* 메모리와 주고받을 값으로 데이터와 명령어를 저장한다. CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터이다.

</br>

![cpu 내부구성](https://github.com/kangssu/cs-study/assets/83870420/4bda0f66-3489-401f-8b0a-f0b8247b1219)

위 이미지에서 5번에 무조건 +1이 되는건 아니다. 순차적인 실행 흐름이 끊기는 경우는 특정 메모리 주소로 실행 흐름을 이동하는 명령어를 실행할 경우 기타 등등..이 존재한다.

</br>

#### (5) 플래그 레지스터
* CPU가 계산한 부가적인 정보 또는 연산 결과를 저장한다. 플래그 레지스터를 읽으면 현재 상태를 읽을 수 있다. CPU가 어떤 연산을 했는지를 파악할 수 있다.

#### (6) 범용 레지스터
* 다양하고 일반적인 상황에서 자유롭게 사용한다. 메모리 주소 레지스터는 주소만인데 범용 레지스터는 주소, 명령어, 데이터 전부 담을 수 있다.

#### (7) 스택 포인터, 베이스 레지스터 `주소 지정에 사용함`
* **스택 포인터(스택 주소 지정 방식):** 스택의 꼭대기를 가리키는 레지스터로 스택이 어디까지 차 있는지에 대한 표시이다. 만약에 스택 포인터가 4번지를 가르킨다면 스택이 4번지까지 채워져 있다고 보면 된다. (메모리 내에 스택 영역이 지정 되어있음)
* **베이스 레지스터(변위 주소 지정 방식):** 오퍼랜드 필드 값과 특정 레지스터의 값을 더하여 유효 주소를 얻는다. **오퍼랜드+프로그램 카운터는 상대 주소 지정방식**으로 +3, -3 이런식으로 실행할 명령어의 위치가 변경된다. / **오퍼랜드+베이스 레지스터는 베이스 레지스터 주소 지정 방식**으로 베이스 레지스터에 기준 값이 담기고 오퍼랜드에 어느정도 떨어질 값을 더하는데 예를 들면 베이스 레지스터가 300번지고 오퍼랜드가 50이면 200에서 50 떨어진 주소를 찾는다.

</br>

### 명령어 사이클과 인터럽트
#### 명령어 사이클
* **프로그램 속 명령어들은 일정한 주기가 반복되며 실행**되는데 이 주기를 명령어 사이클이라고 한다.
* 메모리에 있는 값을 **CPU 내부로 가지고 오는 작업을 인출**이라고 하며, **갖고 오는 주기를 인출 사이클**이라고 한다. 갖고 온 다음에는 **실행 사이클**이 돈다. 즉, 인출 ➡️ 실행 ➡️ 인출 ➡️.....이 반복된다고 생각하면 된다.
* 만약 간접 주소 지정 방식이라면 인출을 하더라도 바로 실행이 불가능한 경우도 있다.
* 이때 인출 사이클이 돌때 간접 사이클이 돌고 그 다음에 실행 사이클이 돌게 된다.

#### 인터럽트
* 위의 명령어 사이클 = 정해진 사이클대로 흘러가는 것을 중단시키는 것을 인터럽트라고 한다.
* CPU가 빠르게 처리할 일이 생겼을 때 = 급한 업무가 있는데 하던거 잠시 멈추고 이거 먼저 처리해줘라고 할 때와 동일하다.

**(1) 동기 인터럽트(예외)**</br>
* Exception이라고 하는데 말 그대로 예외적인 상황에 처리하는 것이다. (이런 종류가 있다 정도로만..추후 다룰 예정)

**(2) 비동기 인터럽트(하드웨어 인터럽트)**</br>
* 주로 입출력장치에 의해 발생하는데 다른 하드웨어에서 발생시킨다고 보면 된다. = 알림(프린트 출력 완료되었다는 알림?신호!를 CPU에 인터럽트)

```
// (예시) 마우스 커서 움직일 때
1. 마우스를 움직이면 CPU에 인터럽트를 보내고 
2. CPU는 인터럽트를 인지하면 현재 작업을 멈추고
3. OS 내부에 있는 Mouse Interrupt Service Routine으로 점프해서
4. 커서를 이동시킨 좌표를 모니터상에 표현해준 다음에
5. 다시 잠시 멈췄던 작업으로 돌아간다.
```

#### 💡 그렇다면, 하드웨어 인터럽트를 왜 쓰는가?
입출력 작업 도중에도 효율적으로 명령어를 처리하기 위함이다. 즉, 하드웨어 인터럽트한테 일을 맡겨놓고 CPU는 자신의 일을 하다가 인터럽트로 인해 알림을 받게 되면 자신의 일을 멈추고 확인할 수 있게 된다. (비동기 인터럽트라고 하는 이유가 여기 있는 것 같다.)

인터럽트를 사용하지 않는다면 CPU가 작업이 완료되었나?x10000 계속 확인할 수 밖에 없기 때문이다.

#### 💡그렇다면, 현재 작업은 어디에 저장해두는가?
위에 내용을 보면 결국 CPU는 인터럽트가 오면 현재 작업을 멈추는데 이때 멈춘 작업을 어디에 저장하는지가 궁금했다. 현재 작업을 스택 영역에 백업하고 인터럽트의 작업이 끝나면 스택에 저장했던 값을 불러와서 원래 하던 작업을 마무리한다.

</br>

**(2-1) 하드웨어 인터럽트의 처리 순서**</br>
입출력장치는 CPU에 **인터럽트 요청 신호** 호출 ➡️ CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인 진행 ➡️ CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그(플래그 레지스터)**를 통해 현재 인터럽트를 받을 수 있는지 확인 ➡️ 인터럽트를 받을 수 있다면 CPU는 현재 작업 백업 진행 ➡️ CPU는 **인터럽트 벡터**를 참조하여 인터럽트 서비스 루틴 실행 ➡️ **인터럽트 서비스 루틴** 실행 종료 ➡️ 백업해둔 작업을 복구하여 실행 재개

![인터럽트](https://github.com/kangssu/cs-study/assets/83870420/132e67e6-63ab-4e56-83e2-3b34ed1cd094)



#### 💡 인터럽트 용어 정리
|명칭| 의미           |
|---------------|-------------------------------|
|인터럽트 요청 신호|CPU의 작업을 방해하는 인터럽트에 대한 요청이다.|
|인터럽트 플래그|인터럽트 요청 신호를 받아들일지, 무시할지를 결정한다.|
|인터럽트 백터|각각의 인터럽트를 구분하기 위한 정보로 어디서부터 시작점인지 확인 가능하다.|
|인터럽트 서비스 루틴|해당 인터럽트를 어떻게 처리하기 위한 프로그램(마우스를 어떻게 처리해주세요..등) -> 메모리 저장됨|

⚠️ *모든 인터럽트를 인터럽트 플래그로 막을 수 있는 건 아니다. 막을 수 있는 인터럽트와 막을 수 없는 인터럽트로 나뉘기도 하다.*