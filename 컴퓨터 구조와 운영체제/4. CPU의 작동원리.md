# 4. CPU의 작동원리

### ALU와 제어장치
> ALU가 구성하는 회로, 제어장치를 구성하는 회로는 해당 챕터에서 다루지 않는다. ALU가 내보내고 받아들이는 정보, 제어장치가 내보내고 받아들이는 정보에 대한 챕터이다.

#### ALU
* 레지스터로 부터 피연산자를 받아들이고 제어장치로부터 제어 신호를 받아들여서 계산을 하게 된다. 계산 값을 레지스터에 다시 담아준다.
* 계산 값을 메모리가 아닌 레지스터에 저장하는 이유는 CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 더 빠르기 때문에 사용한다.

#### 플래그
* 연산 결과에 대한 부가 정보로 양수인지, 음수인지 내보내지고 플래그 레지스터에 저장이 되어진다. 
* 예를 들어 계산 값이 -10일 경우 -10이 레지스터에 저장되면서 플래그 레지스터에는 해당 값이 음수라고 아래처럼 저장이 된다. 즉, 음수일 때는 부호 플래그만 1로 들어가면 음수라고 인식한다고 보면 된다.
* `부호 플래그: 1` `제로 플래그: 0` `캐리 플래그: 0` `오버플로우 플래그: 0` `인터럽트 플래그: 0` `슈퍼바이저 플래그: 0`

</br>

#### 💡 플래그 종류
|플래그 종류| 의미           | 사용 예시  | 
|-------------------|--------------------|:--------------------:|
|부호 플래그|연산한 결과의 부호를 나타낸다.|1일 경우 음수, 0일 경우 양수|
|제로 플래그|연산 결과가 0인지 여부를 나타낸다.|1일 경우 0, 0일 경우 0이 아닌 수|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.|1일 경우 발생했고, 0일 경우 발생하지 않음|
|오버플로우 플래그|오버플로우가 발생했는지를 나타낸다.|1일 경우 발생했고, 0일 경우 발생하지 않음|
|인터럽트 플래그|인터럽트가 가능한지를 나타낸다.|1일 경우 인터럽트 가능, 0일 경우 불가능함|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.|1일 경우 커널 모드 실행중, 0일 경우 사용자 모드 실행중|

</br>

#### 제어장치(받아들이는 정보 3가지)
**(1) 클럭(= 시계)**
* 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위로 일정한 박자에 맞춰서 발생하는 신호로 이해하면 된다.
* 메모리에서 명령어 가져오는 주기는 클럭주기x5 단위로 수행된다고 보면 된다.

**(2) 명령어 레지스터(= 해석할 명령어)**
* 명령어 레지스터로부터 해석할 명령어를 받아들이고 제어장치에서 해석한다.
* 다음 강의에 자세히..😅

**(3) 플래그**
* 플래그 레지스터(= CPU가 연산 결과로서 받아들이는 부가 정보)의 플래그를 받아야 해석할 명령어가 음수인지, 양수인지 부가 정보에 대해 해석할 수 있다.

</br>

### 레지스터
* 레지스터는 CPU 내부의 작은 임시저장장치로 프로그램의 명령어, 데이터는 실행 전후로 레지스터에 저장된다.

#### (1) 프로그램 카운터
* 메모리에서 가져올 명령어의 주소를 저장한다.(= 메모리에서 읽어 들일 명령어의 주소)

#### (2) 명령어 레지스터
* 방금 메모리에서 읽어 들인 명령어로 제어장치가 해석할 명령어이다.

#### (3) 메모리 주소 레지스터
* CPU가 읽어 들이고자 하는 주소를 주소 버스를 보낼 때 거치는 레지스터이다.

#### (4) 메모리 버퍼 레지스터
* 메모리와 주고받을 값으로 데이터와 명령어를 저장한다. CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터이다.

</br>

![cpu 내부구성](https://github.com/kangssu/cs-study/assets/83870420/4bda0f66-3489-401f-8b0a-f0b8247b1219)

위 이미지에서 5번에 무조건 +1이 되는건 아니다. 순차적인 실행 흐름이 끊기는 경우는 특정 메모리 주소로 실행 흐름을 이동하는 명령어를 실행할 경우 기타 등등..이 존재한다.

</br>

#### (5) 플래그 레지스터
* CPU가 계산한 부가적인 정보 또는 연산 결과를 저장한다. 플래그 레지스터를 읽으면 현재 상태를 읽을 수 있다. CPU가 어떤 연산을 했는지를 파악할 수 있다.

#### (6) 범용 레지스터
* 다양하고 일반적인 상황에서 자유롭게 사용한다. 메모리 주소 레지스터는 주소만인데 범용 레지스터는 주소, 명령어, 데이터 전부 담을 수 있다.

#### (7) 스택 포인터, 베이스 레지스터 `주소 지정에 사용함`
* **스택 포인터(스택 주소 지정 방식):** 스택의 꼭대기를 가리키는 레지스터로 스택이 어디까지 차 있는지에 대한 표시이다. 만약에 스택 포인터가 4번지를 가르킨다면 스택이 4번지까지 채워져 있다고 보면 된다. (메모리 내에 스택 영역이 지정 되어있음)
* **베이스 레지스터(변위 주소 지정 방식):** 오퍼랜드 필드 값과 특정 레지스터의 값을 더하여 유효 주소를 얻는다. **오퍼랜드+프로그램 카운터는 상대 주소 지정방식**으로 +3, -3 이런식으로 실행할 명령어의 위치가 변경된다. / **오퍼랜드+베이스 레지스터는 베이스 레지스터 주소 지정 방식**으로 베이스 레지스터에 기준 값이 담기고 오퍼랜드에 어느정도 떨어질 값을 더하는데 예를 들면 베이스 레지스터가 300번지고 오퍼랜드가 50이면 200에서 50 떨어진 주소를 찾는다.