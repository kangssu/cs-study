# 5. CPU 성능 향상 기법

### 클럭
컴퓨터 부품들은 클럭 신호에 맞춰서 움직이는데 클럭 신호의 속도가 높아지면 CPU의 명령어 사이클을 더 빠르게 반복되기 때문에 이 속도에 맞춰서 작동할 것이다.

클럭 속도 = CPU의 속도, 헤르츠(Hz) 단위로 측정되며 1초에 클럭이 반복되는 횟수라고 보면 된다.(1초에 1번 반복되면 1Hz, 1초에 100번 반복되면 100Hz)

#### 💡 그렇다면, 클럭 신호를 높인다면 CPU가 무한대로 빨라질까?
그렇진 않다. 클럭을 필요 이상으로 높이면 발열이 심해진다. 예를 들어 영상 편집등 장시간을 하게 되면 발열이 높아지는 것을 알 수 있다. 그렇기 때문에 클럭 속도를 높이는 것은 CPU를 빠르게 만들지만 클럭 속도만으로 CPU 성능을 올리는 것엔 한계가 있다.

</br>

### 코어와 멀티 코어
* 전통적으로는 명령어를 실행하는 부품은 하나만 존재했지만 현재 CPU에는 명령어를 실행하는 부품이 여러개 존재하며 해당 명칭을 **코어**라고 한다.

![core](https://github.com/kangssu/cs-study/assets/83870420/5f72d5df-eece-4656-aa1c-a0709bbe87cf)

* 코어 수에 비례해서 속도가 빨라지지는 않는다.
* 예를 들어, 조별 과제의 경우 4명일 때 생산성이 x4가 될 수도 있지만.. 상황에 따라 x2가 될 수도 있기 때문이다. 즉, 코어마다 처리할 연산이 적절하게 분배되지 않는다면 코어 수에 비례해서 연산 속도가 증가하지는 않는다.

</br>

### 스레드와 멀티 스레드
* 스레드는 하드웨어적 스레드와 소프트웨어적 스레드가 존재한다.

#### (1) 하드웨어 스레드(= 논리 프로세서)
* **하나의 코어가 동시에 처리하는 명령어 단위**로 1코어가 한 번에 하나의 명령어만을 처리한다면 1코어 1스레드 CPU이고, 2코어가 한 번에 두개의 명령어를 처리한다면 2코어 4스레드 CPU이다.
* 만약 1개의 코어가 2개의 스레드를 처리한다면 멀티 스레드 프로세서, 멀티스레드 CPU라고 부른다.

#### 💡 멀티 스레드 프로세서를 구성하기 위해서는?
* 실제로 설계하기에는 어려운 일이지만 가장 큰 핵심은 **레지스터**이다.
* 하나의 명령어를 실행하기 위해 꼭 필요한 레지스터들은 레지스터 세트이다.(레지스터 세트는 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터 묶음이다.)
* 하나의 코어 내부에 레지스터 세트가 여러 개가 있다면 하나의 코어가 여러 개의 명령어를 동시에 처리할 수 있다.
* 예를 들어, 하나의 코어 내부에 프로그램 카운터가 2개일 경우에 다음으로 실행할 명령어의 주소를 2개 저장할 수가 있다.
* 메모리의 입장에서는 몇 코어/몇 스레드인지는 알 수 없다. 대신 2코어 4스레드일 경우에 명령어를 한 번에 4개씩 실행해주는 것까지만 알고 있기 때문에 논리 프로세서라고도 부른다.

![cpu](https://github.com/kangssu/cs-study/assets/83870420/26cf272f-b386-40dd-98c1-958677c36c08)

💡 위 이미지에서 논리 프로세서는 16개이기 때문에 한 번에 16개씩 실행해주는 것으로 이해하면 된다.

</br>

#### (2) 소프트웨어적 스레드
* **하나의 프로그램에서 독립적으로 실행되는 단위**로 한 프로그램이 순차적으로 실행되는 구조를 싱글 스레드, 하나의 프로그램에서 동시에 두개의 영역이 실행되는 구조를 멀티 스레드라고 한다.
* 예를 들어, 사용자가 입력한 내용을 보여주는 기능/사용자가 입력한 내용의 맞춤법 검사 기능/사용자가 입력한 내용 저장하는 기능일 때 하나의 프로그램(=메모리)에서 3개의 실행흐름이 동시에 진행된다.
* 1코어 1스레드여도 여러 소프트웨어적 스레드를 만들 수 있다.
* 나중에 운영체제에서 다시...

</br>

### 명령어 병렬 처리 기법
#### (1) 명령어 파이프라인
* 명령어가 처리되는 과정을 비슷한 시간 간격으로 나누면 명령어 인출 ➡️ 명령어 해석 ➡️ 명령어 실행 ➡️ 결과 저장으로 4가지로 나눌 수 있다.(단계는 조금씩 다름)
* 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있다. 예를 들어 한 사람이 해석/해석 단계를 하는게 아니라 인출/해석 이런식으로 다른 단계를 동시에 처리한다고 이해하면 된다.

#### 파이프라인의 위험은?
위 단계처럼 동시에 처리할 수 없는 상황도 있다. 데이터 위험, 제어 위험, 구조적 위험 = 파이프라인 위험이 존재한다.

* **데이터 위험 :** 명령어 간의 의존성에 의해 발생하는데 모든 명령어를 동시에 처리할 수는 없다. 즉, 이전 명령어가 끝나야 실행할 수 있는 경우이다.
```
// 즉, 아래 예시를 보면 명령어 2에서 R1의 경우
// 명령어 1이 무조건 실행이 끝난 다음에 값을 가져와서 처리할 수 있는 명령어이다.
명령어 1: R1 = R2 + R3(= R2 레지스터와 R3 레지스터 값을 더해서 R1 레지스터에 저장한다.)
명령어 2: R4 = R1 + R5(= 위 R1 레지스터 값과 R5 레지스터 값을 더해서 R4 레지스터에 저장한다.)
```
* **제어 위험 :** 프로그램 카운터의 갑작스러운 변화이다. 예를 들어 메모리 10번지를 실행하는데 이때 11번지를 다음에 실행하는게 아니라 100번지로 점프해야할 경우이다.그렇기 때문에 11번지, 12번지를 실행할 필요가 없다.(JUMP, INTERRUPT 명령어 등등..)
* **구조 위험 :** 서로 다른 명령어가 CPU 부품(ALU, 레지스터)를 쓰려고 할 때 발생한다.

#### 💡 제어 위험을 예방하기 위한 것은 분기예측!

#### (2) 슈퍼스칼라
* CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조이다. 예를 들면 해석/해석 단계를 동시에 실행할 수 있다.
* 슈퍼스칼라를 사용하면 파이프라인 개수에 비례하여 처리 속도가 증가하지만(이론적으로는..) 파이프라인 위험도의 증가로 인해서 파이프라인 개수에 비례해서 꼭 증가하진 않는다.

#### (3) 비순차적 명령어 처리
* 명령어들간의 합법적인 새치기라고 이해하면 된다. 

</br>

### 명령어 집합 구조, CISC와 RISC(명령어 집합의 두 축)
#### 명령어 집합(구조) = CPU의 언어
* "CPU는 명령어를 실행한다." -> 그렇다면 이 세상의 모든 CPU가 똑같이 생긴 명령어를 실행하진 않고 연산,주소 지정 방식 등은 CPU마다 다르기 때문이다. 
* **CPU가 이해할 수 있는 명령어들의 모음이라고 생각하면 된다.**
* 예를 들어 인텔 CPU 컴퓨터에서 만든 실행 파일을 그대로 아이폰에 옮겨 특별한 설정 없이 바로 실행하면 실행이 안 된다. 그 이유는 인텔 CPU에서 이해할 수 있는 명령어와 아이폰에서 이해할 수 있는 명령어는 다르기 때문이다.
* 명령어는 CPU의 언어인 셈인데 명령어가 달라지면 나비효과로 많은 것들이 달라진다.(명령어 해석 방식, 레지스터의 종류와 개수 등등...)
* ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이기도 하다.(= 소프트웨어가 명령어는 이렇게 생겼어 -> 하드웨어가 그렇다면 이런 명령어가 동작하기 편하게 만들어야겠다..)

</br>

#### CISC(Complex Instruction Set Computer)
* 복잡한 명령어 집합을 활용하는 컴퓨터(= CPU)로 복잡하고 다양한 명령어를 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다.
* x86, x86-64는 CISC 기반 명령어 집합 구조이다.
* 다양하고 강력한 명령어를 활용하기 때문에 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
* 메모리를 아끼면서 개발해야했던 시절엔 인기가 많았지만 명령어 파이프라이닝이 불리하다는 치명적인 단점이 존재하다.
* 즉, 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하기 않고 여러 클럭 주기가 필요하다.

![클럭주기](https://github.com/user-attachments/assets/6ba7ec1b-71e2-4fe9-ae01-37e3f7b969d2)

</br>

#### RISC(Reduced Instruction Set Computer)
* 명령어의 종류가 적고, 짧고 규격화된 명령어를 사용한다. 가급적 1클럭 내외로 명령어를 수행한다.
* 메모리 접근을 최소화하고 레지스터를 십분 활용하며, 명령어 종류가 CISC보다 적기 때문에 더 많은 명령어로 동작시킨다.

