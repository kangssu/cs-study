# 3. 명령어
> 개발자가 작성한 소스 코드를 컴퓨터는 직독직해 할 수가 없다. 개발을 할 때 사용하는 언어는 고급 언어이고 고급 언어를 컴퓨터가 이해할 수 있는 저급 언어로 변환된다.

</br>

### 고급 언어와 저급 언어
* 고급 언어는 개발자가 이해하기 쉽게 만든 언어로 C, C++, Java, Python이고 저급 언어는 컴퓨터가 이해하고 실행하기 위한 언어이다.
* 저급 언어에는 기계어와 어셈블리어로 나눠지는데 **기계어는 이진수(0과 1)로 표현된 것이고 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 것이 어셈블리어**이다.

</br>

### 컴파일 언어와 인터프리트 언어
* **고급 언어가 저급 언어로 변환**되는 방식은 컴파일과 인터프리트가 있다.
* **컴파일 언어**는 고급 언어(= 소스 코드)가 컴파일러에 의해 컴파일 되어 저급 언어(= 목적 코드)로 변환되는데 소스 코드를 한 번에 확인하여 오류가 없는지 체크한 다음에 통째로 컴파일한다. 즉, 중간에 오류가 발생하면 소스 코드 전체가 실행되지 않는다.
* **인터프리트 언어**는 인터프리터에 의해 한 줄씩 실행하고 소스 코드 전체가 저급 언어로 변환되기까지 기다리지 않아도 된다. 즉, 중간에 오류가 발생하기 전까지 실행된다.
* [컴파일 & 인터프리트 과정보기](https://godbolt.org/)

</br>

### 💡 모든 프로그래밍 언어는 컴파일 언어와 인터프리트 언어로 명확히 나눠질까?
이 물음에 대한 대답은 명확히 나눠져 있다고 생각했지만 이 강의에서는 명확히 나눠져 있다고 생각하는 것이 아니라 컴파일 방식과 인터프리트 방식이 있는데 고급 언어를 저급 언어로 변환하기 위한 방식이라고 알고 있으면 된다고 한다!

</br>

### 명령어의 구조

**무엇을 대상으로, 무엇을 수행하라 = “영수야, 방 좀 치워줘!” = 영수(무엇을 대상으로), 방 좀 치워줘(무엇을 수행하라)**

* 명령어는 연산코드와 오퍼랜드로 구성되어 있으며, 연산코드는 수행할 연산이 오퍼랜드는 연산에 사용될 데이터나 연산에 사용될 데이터의 주소(= 주소필드)이다.
* 아래 이미지에서 파란색이 연산코드, 그 오른쪽이 오퍼랜드로 보면 된다.
![어셈블리어](https://github.com/kangssu/cs-study/assets/83870420/00476109-d0ba-496d-9d41-75f12cabd70b)

* 오퍼랜드의 경우 없을 수도 있고 1개 이상이 될 수도 있다.(1개 이상은 콤마로 구분함)

</br>

**연산코드(외울 필요는 X)**
* **데이터 전송시** MOVE: 데이터를 옮겨라, STORE: 메모리에 저장하라, LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라, PUSH: 스택에 데이터를 저장하라, POP: 스택의 최상단 데이터를 가져와라
* **스택**은 한쪽 끝이 막혀있는 자료구조로 먼저 들어간 데이터가 가장 나중에 나오게 된다.
* **큐**는 양쪽 끝이 뚫여있는 자료구조이기 때문에 먼저 들어간 데이터가 먼저 나오게 된다.
* **제어 흐름 변경**은 JUMP: 특정 주소로 실행 주소를 옮겨라, CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라, HALT: 프로그램의 실행을 멈춰라, CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라, RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
* **입출력 제어**는 READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라, WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라, START IO: 입출력 장치를 시작하라, TEST IO: 입출력 장치의 상태를 확인하라

</br>

### 명령어 주소 지정 방식

* 유효 주소 : 연산에 사용할 데이터가 저장된 위치이다.
* 명령어 주소 지정 방식 : 연산에 사용할 데이터가 저장된 위치를 찾는 방법, 유효 주소를 찾는 방법, 다양한 명령어 주소 지정 방식들이다.

### 💡 왜 저장된 위치를 쓰는가?

**명령어 내에서 표현할 수 있는 데이터의 크기가 제한**되기 때문에 예를 들어 명령어의 크기가 2-주소/16비트라고 하고 16-12까지 4비트 연산코드, 12-6  = 6비트 / 6-0 = 6비트 이므로 데이터의 크기는 2의 6 = 64이다. 

또 예를 들면, 3-주소/16비트라고 할 경우에 16-12까지 4비트 연산코드, 12-8 = 4비트 / 8-4 = 4비트 / 4-0 = 4비트로 데이터의 크기는 2의 4 = 16이다. 이 경우에는 하나의 오퍼랜드가 첫번째 예시보다 더 작아질 수 밖에 없는 상황이다. 

![명령어 주소 지정 방식](https://github.com/kangssu/cs-study/assets/83870420/7f5751ff-341a-4ae3-98e1-f2bde373a8b5)

그렇기 때문에 오퍼랜드에 메모리 주소를 사용한다면 위의 하나의 오퍼랜드가 4비트가 아닌 메모리의 16비트를 사용할 수 있기 때문에 4비트보다 큰 명령어를 사용할 수 있다고 보면 된다.(레지스터도 가능)

</br>

**(1) 즉시 주소 지정 방식**
* 연산에 사용할 데이터를 오퍼랜드에 직접 명시하기 때문에 간단하고 데이터 크기가 작아질 수 있지만 빠르다.
* 연산코드+주소값을 사용하는 것이 아닌 연산코드+데이터를 쓴다고 보면 된다.

**(2) 직접 주소 지정 방식**
* 오퍼랜드에 유효 주소를 직접적으로 명시하기 때문에 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어들 수 있다.
* 예를 들면 메모리의 주소를 명시함으로써 하나의 오퍼랜드에 6비트를 사용할 수 있지만 주소 값을 넣으면 4비트? 이런식으로 크기가 줄어든다고 생각하면 된다.

**(3) 간접 주소 지정 방식**
* 오퍼랜드에 유효 주소의 주소를 명시하기 때문에 위의 2가지보다 속도가 느리다.
* 예를 들어 메모리에 1번지에는 2번지라는 메모리 주소를 넣고 2번지에 연산에 사용할 데이터를 넣을 경우, 오퍼랜드에 유효 주소의 주소를 명시할 수 있다.

**(4) 레지스터 주소 지정 방식**
* 연산에 사용할 데이터가 저장된 레지스터를 명시하기 때문에 메모리보다 레지스터에 접근하는 것이 빠르다. 그 이유는 메모리가 CPU 내에 존재하지 않기 때문에 CPU 내에 존재하는 레지스터가 더 빠를 수 밖에 없다.

**(5) 레지스터 간접 주소 지정 방식**
* 연산에 사용할 데이터를 메모리에 저장하고 해당 주소를 저장한 레지스터를 오퍼랜드 필드에 명시한다.
